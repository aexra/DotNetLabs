```cs
F MakeAdder(double delta)
{
  return x => {
    return x + delta;
  };
}
/////////////////////////////////
ВРЕМЯ ЖИЗНИ delta ЗАКОНЧИЛОСЬ ТУТ
/////////////////////////////////

var inc = MakeAdder(1);
var dec3 = MakeAdder(-3);

inc(4); // 5
dec3(4); // 1
```

Когда в теле функции (чаще всего это лямбды - анонимные функции) встречаются какие-либо переменные, время жизни которых меньше чем время жизни рассматриваемой функции, то такая функция **захватывает (*замыкает*)** эти переменные с собой эти переменные и уносит их с собой в своем специальном контексте "**Контекст вызова**".

Например:<br>
Переменная ```inc``` имеет ссылки на *код делегата* и ссылки на *контекст*<br>
Переменная ```dec3``` имеет ссылку на тот же *код делегата* и ссылки на свой *контекст*<br>

```cs
? MakeTab(double x0, double x1, double step)
{
  return f => tab(x0, x1, step, f);
}

var t0_1 = MakeTab(0, 1, 0.01);

t0_1(Math.Sin);
t0_1(x => 2 * x + 1);
```

### Особенности делегатов, которых нет в других функциональных языках
#### Мультиделегат

```cs
void LogConsole(object o) => Console.WriteLine(o);
void LogFile(object o) => File.AppendText("a.log", o.ToString());

// МУЛЬТИДЕЛЕГАТ - строка запишется и в консоль и в файл
var l = LogConsole;
l += LogFile;

// МУЛЬТИДЕЛЕГАТ - НЕ множество
l += LogConsole; // Будет двойной вызов

// Можно убирать (по 1)
l -= LogConsole;

// Если убрать всё, то l = null
l -= LogConsole;
l -= LogFile;

l == null; // true
```

> [!NOTE]
> Среда .NET не специфицирует порядок вызова

# Классы

```cs
[<модификаторы>] class <имя>[:<предок>[,<список интерфейсов>]]
{
  <члены класса>
}
```
